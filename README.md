# ansible-cfssl-raw

Some Ansible plugins and an example playbook for cfssl-based certificate
generation:

 * An action plugin `cfssl` to generate certificates from Ansible playbooks
 * An action plugin `local_copy` to copy Ansible variables to a local path with
   optional vault encryption.

I'm adding them here in case they're useful to anyone else in the future.

## Running a cfssl CA

I have an Ansible role for starting the `cfssl` service as well, but it is not
generalized for any environment / distribution. The main pieces of that role are
below, so you should be able to stand up your own `cfssl` using Docker fairly easily.

### Configuration

This is the configuration for the Goose database migration tool. Will revisit below.

**files/dbconf.yml:**
```
---
prod:
  driver: sqlite3
  open: /data/db/ca_certs_prod.db
```

This is the configuration for `cfssl` to find the database.

**files/ca-db-config.yml:**
```
---
driver: sqlite3
data_source: "/data/db/ca_certs_prod.db"
```

-----

The `cfssl` configuration is in JSON, but I maintain it in YAML for ease of
editing, commenting. You'll need to tweak it to contain the profiles you want
to use, expiration times, name whitelist, etc.

**templates/ca-config.yml.j2:**
```
---
signing:
  default:
    expiry: 8760h
    is_ca: false

  profiles:
    server:
      expiry: 8760h
      backdate: 1h
      not_after: "2017-12-31T23:59:59Z"
      usages:
        - signing
        - key encipherment
        - server auth
      name_whitelist: "^.+\\.(prod|stage)\\.example\\.com$"

    client:
      expiry: 8760h
      backdate: 1h
      not_after: "2017-12-31T23:59:59Z"
      usages:
        - signing
        - key encipherment
        - client auth
      name_whitelist: "^.+\\.(prod|stage)\\.example\\.com$"
```

### Copying the templated configs

Example of converting the YAML configs to JSON:

**[playbook].yml:**
```
- name: Write CFSSL CA database config files
  copy:
    content: "{{ lookup('file', 'ca-db-config.yml') | from_yaml | to_nice_json }}"
    dest: '/data/config/ca-db-config.json'
    mode: 0600
    owner: root
    group: root
```

### Starting the service

The steps below assume all the following paths and files exist, copied / generated by other tasks:

```
/data/db/
	ca_certs_prod.db	- sqlite db created / updated by goose migrations

/data/certs/
	ca-server.pem		- cfssl server's certificate for mutual TLS
	ca-server-key.pem	- cfssl server's private key for mutual TLS
	int-ca.pem			- your intermediate CA cert
	int-ca-key.pem		- your intermediate CA's private key for cert signing
	root-ca.pem			- your root CA cert
	ca-bundle.pem		- bundle of intermediate and root CA certs

/data/configs/
	ca-config.json		- cfssl's CA config
	ca-db-config.json	- cfssl's database config
```

-----

In order to run database migrations you either need the `goose` command available on the system, or create a derived `cfssl` Docker image that embeds the `goose` command.  I chose the latter:

**Dockerfile:**
```
FROM cfssl/cfssl:master

# Embed the goose database migration tool inside the cfssl image
# This lets us directly run database migrations before deployment
# of new versions of the cfssl image.

RUN go get bitbucket.org/liamstask/goose/cmd/goose

WORKDIR /data

# Force explicit command to be specified
ENTRYPOINT []
```

-----

Since `cfssl` uses Goose for database migrations you'll need a way of running
these migrations whenever you redeploy the service.

**[playbook].yml:**
```
- name: Remove old database migration files
  file:
    path: /data/db/migrations
    state: absent

- name: Create temporary container to synchronize the current CFSSL database migrations
  docker_container:
    name: temporary
    image: '{{ docker_registry }}/cfssl/cfssl:latest'
    pull: yes
    recreate: yes
    state: started
    command: /bin/bash

- name: Copy database migrations from temporary container
  command: docker cp temporary:/go/src/github.com/cloudflare/cfssl/certdb/sqlite/migrations .
  args:
    chdir: /data/db

- name: Destroy temporary container
  docker_container:
    name: temporary
    state: absent
```

-----

Upgrade the CA database by running `goose`

**[playbook].yml:**
```
- name: Upgrade CA database
  docker_container:
    name: database-upgrade
    image: '{{ docker_registry }}/cfssl/cfssl:latest'
    pull: yes
    recreate: yes
    state: started
    command: >
      goose
      -env prod
      -path /data/db
      up
    volumes:
      - '/data:/data'

- name: Destroy CA database upgrade container
  docker_container:
    name: database-upgrade
    state: absent
```

-----

Now you can start the `cfssl` service. 

Note that I hard-code the `-mutual-tls-cn` to correspond to a client
certificate CN (`ca-client.ca.example.com`) that cannot be issued by this
`cfssl` service, due to the `name_whitelist`.  It is generated offline and used
with our `cfssl` action.

**[playbook].yml:**
```
- name: Start CFSSL service for Intermediate CA
  docker_container:
    name: ca-service
    image: '{{ docker_registry }}/cfssl/cfssl:cfssl'
    restart: yes
    state: started
    recreate: yes
    command: >
      /go/bin/cfssl
      serve
      -address 0.0.0.0
      -ca /data/certs/int-ca.pem
      -ca-key /data/certs/int-ca-key.pem
      -ca-bundle /data/certs/ca-bundle.pem
      -mutual-tls-ca /data/certs/ca-bundle.pem
      -mutual-tls-cn 'ca-client\.ca\.example\.com'
      -tls-cert /data/certs/ca-server.pem
      -tls-key /data/certs/ca-server-key.pem
      -config /data/config/ca-config.json
      -db-config /data/config/ca-db-config.json
    ports:
      - '0.0.0.0:8001:8888'
    volumes:
      - '/data:/data'
```


